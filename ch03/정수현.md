# 이미지 지연로딩

## 네트워크 분석

- custom throttling
    - 크롬 개발자 도구 Network 탭의 throttling 옵션 > `Custom` > `Add...`
        - `Profile Name` : 옵션에 디스플레이될 이름
        - `Download`: 다운로드 속도(kb/s)
        - `Upload`: 업로드 속도(kb/s)
        - Latency
- Fast 3G
    - `Download`: 1500kb/s
    - `Upload`: 750kb/s
- Slow 3G
    - `Download`: 780kb/s
    - `Upload`: 330kb/s
- 보통 업로드 하는 리소스보다 다운로드 하는 리소스가 많으므로, **업로드 속도 < 다운로드 속도**이다.
    - 쉬운 예시) 카톡 받기 - 다운로드, 카톡 보내기 - 업로드

## Intersection Observer
- 이미지 다운로드를 위해 사용자의 첫 화면에서 보이는 콘텐츠가 나중에 로드된다면 사용자 경험에 좋지 않다.
- 당장 사용되지 않는 이미지를 나중에 다운로드되도록 최적화할 수 있다. 
    - 언제 다운로드? > 이미지가 화면에 보이는 순간 또는 그 직전(뷰포트에 이미지가 표시될 위치까지 스크롤되었을 때)
    - 스크롤이 이동했을 때 해당 뷰포트에 이미지를 보이게 할지 판단해야 하는데
        - 스크롤(scroll) 이벤트에 이 로직을 넣으면 스크롤할 때마다 해당 로직이 아주 많이 실행된다.
        - lodash의 throttle과 같은 방식으로 처리할 수 있겠지만, 근본적인 해결 방법이 될 수는 없다. 
- Intersection Observer
    - 브라우저에서 제공하는 API
    - 웹 페이지의 특정 요소를 관찰(observe)하면 페이지 스크롤 시 해당 요소가 화면에 들어왔는지 아닌지 알려줌
    - 스크롤 이벤트처럼 스크롤 할 때마다 함수를 호출하는 것이 아니라, 요소가 화면에 들어왔을 때만 함수를 호출
```js
// Intersection Observer의 옵션
const options = {
    root: null, // 대상 객체의 가시성을 확인할 때 사용되는 뷰포트 요소(default = null(브라우저 뷰포트로 설정됨))
    rootMarginL '0px', // root 요소의 여백 -> root의 가시 범위를 가상으로 확장하거나 축소 가능
    threshold: 1.0 // 가시성 퍼센티지 -> 대상 요소가 어느 정도로 보일 때 콜백을 실행할지 결정한다.
                   // 1.0 -> 대상 요소가 모두 보일 때 실행
                   // 0 -> 1px 이라도 보이는 경우 콜백 실행
}

// 가시성이 변경될 때마다 실행되는 함수
// 콜백에서는 첫번째 인자 -> 가시성이 변한 요소(entries)를 배열 형태로 전달받는다.
const callback = (entries, observer) => {
    console.log('Entries', entries)
}

// IntersectionObserver 인스턴스 생성
const observer = new IntersectionObserver(callback, options)

// 원하는 요소를 관찰할 수 있다.
// 대상 요소의 가시성이 변할 때마다 콜백이 실행
observer.observe(document.querySelector('#target-element1'))
observer.observe(document.querySelector('#target-element2'))
```

## 리액트에서 IntersectionObserver 적용

```jsx
import { useRef, useEffect } from 'react'

function Card(props) {
    const imgRef = useRef(null)

    useEffect(() => {
        const options = {}
        const callback = (entries, observer) => {
            console.log('Entries', entries)
        }

    const observer = new IntersectionObserver(callback, options)

    observer.observe(imgRef.current)

    return () => observer.disconnect() // clean-up

    }, []) // 마운트 되었을 때만 IntersectionObserver 인스턴스 생성
    // useEffect를 사용하지 않으면 렌더링할 때마다 인스턴스 생성 --> 대상 요소에 여러 개의 콜백 실행
    

    return (
        // ....
            <img src={props.image} ref={imgRef} />
        // ....
    )
}
```

## callback 함수의 첫번째 인자인 entries

- 배열 형태

<img width="535" alt="image" src="https://github.com/sasha1107/TIL/assets/78977003/b824d64d-2f32-4c74-8cd0-6f6383d2d2cd">

- `isIntersecting` : 해당 요소가 뷰포트 내에 들어왔는지를 나타내는 값
- `boundingClientRect`
- `intersectionRatio`
- `intersectionRect`
- `isVisible`
- `rootBounds`
- `target`
- `time`

## callback 함수에서 이미지 로드 로직 작성

```diff
import { useRef, useEffect } from 'react'

function Card(props) {
    const imgRef = useRef(null)

    useEffect(() => {
        const options = {}
        const callback = (entries, observer) => {
-            console.log('Entries', entries)
+            entries.forEach(entry => {
+                if (entry.isIntersecting) { // 해당 요소가 뷰포트 내로 들어왔다면
+                    entry.target.src = entry.target.dataset.src // img의 src를 할당
+                    observer.unobserve(entry.target) // 해당 요소의 observe를 해제 (한 번 이미지를 로드한 후에는 다시 호출할 필요가 없으므로)
+                }
+            })
        }

    const observer = new IntersectionObserver(callback, options)

    observer.observe(imgRef.current)

    return () => observer.disconnect() // clean-up

    }, []) // 마운트 되었을 때만 IntersectionObserver 인스턴스 생성
    // useEffect를 사용하지 않으면 렌더링할 때마다 인스턴스 생성 --> 대상 요소에 여러 개의 콜백 실행
    

    return (
        // ....
-            <img src={props.image} ref={imgRef} />
+            <img data-src={props.image} ref={imgRef} /> // src값이 할당되지 않기 때문에 해당 이미지를 로드하지 않음
+            // data-src에 넣어 나중에 이미지가 뷰포트에 들어왔을 때 data-src에 있는 값을 src로 옮겨 이미지 로드하기 위함
        // ....
    )
}
```
# 이미지 사이즈 최적화

## 이미지 포맷 종류
|PNG|JPG(JPEG)|Webp|
|:-:|:-:|
|무손실 압축|손실 압축|무손실 & 손실 압축 모두 제공|
|알파 채널 지원(투명도)|투명도 정보 X|브라우저 호환성 문제|

- 사이즈
    - PNG > JPG > WebP
- 화질
    - PNG = WebP > JPG
- 호환성
    - PNG = JPG > WebP

## WebP 변환 서비스 `Squoosh`

- [https://squoosh.app](https://squoosh.app)
- 구글에서 만든 이미지 컨버터 웹 애플리케이션
- 별도의 프로그램 설치 없이 웹에서 이미지를 손쉽게 여러 가지 포맷으로 변환할 수 있다.
- 이미지 변환 옵션
    - Resize
        - Width * Height
    - Compress
        - Quality(압축률)
            - 70 ~ 80% 권장(너무 작으면 화질 ⬇️, 너무 크면 용량⬆️)
        - Effort (CPU 리소스를 어느 정도로 사용할 지, 기본값 4)

## Webp 브라우저 호환성 문제 해결 -> `<picture>`

WebP로만 이미지를 렌더링할 경우 특정 브라우저에서는 제대로 렌더링되지 않을 수도 있다.

**`<picture>`**

- 다양한 타입의 이미지를 렌더링하는 컨테이너로 사용됨
- 브라우저 사이즈에 따라 지정된 이미지를 렌더링하거나 지원되는 타입의 이미지를 찾아 렌더링한다.

### 브라우저 사이즈(뷰포트)에 따라 렌더링

```html
<picture>
  <source media='(min-width: 650px)' srcset='img_pink_flower.jpg'/>
  <source media='(min-width: 465px)' srcset='img_white_flower.jpg'/>
  <img src="img_orange_flower.jpg" alt="flower" style='width: auto;' />
</picture>
```

### 이미지 포맷에 따라 렌더링

```html
<picture>
  <source srcset="photo.avif" type="image/avif" />
  <source srcset="photo.webp" type="image/webp" />
  <img src="photo.jpg" alt="photo" />
</picture>
```

### WebP 이미지를 지원하지 않는 브라우저를 대비하여 `<picture>` 태그 사용

```html
<picture>
  <source data-srcset={props.webp} type="image/webp" />
  <img data-src={photo.image} ref={imgRef} />
</picture>
```

- 가장 상위에 있는 WebP를 우선으로 로드하고
- 브라우저가 WebP를 지원하지 않으면 img 태그에 있는 JPG 이미지를 렌더링

# 동영상 최적화

> 동영상 파일은 이미지처럼 하나의 요청으로 모든 영상을 다운로드하지 않는다.

- 동영상 콘텐츠의 다운로드 요청이 여러개로 나누어진다.(Network 탭 확인)
- 당장 재생이 필요한 앞부분 다운로드 -> 순차적으로 나머지 내용 다운로드
- 동영상 콘텐츠의 특성상 파일 크기가 크기 때문.
- 여러 번 나눠서 다운로드한다 하더라도 애초에 파일이 크면 재생하기까지 꽤 오래 걸린다.

## 동영상 압축

- 동영상 압축 -> 동영상의 화질을 낮추는 방법

### [Media.io])()

- 확장자: `WebM`
- Birate
    - 특정한 시간 단위마다 처리하는 비트의 수
    - 1초에 얼마나 많은 정보를 포함하는가
    - 이 값이 클수록 화질 ⬆️, 사이즈도 ⬆️
- Audio

### WebM 확장자
- webP와 마찬가지로 구글에서 개발한 동영상 포맷
    - 브라우저 호환성 문제
- 웹에 최적화

### WebM 확장자를 지원하지 않는 브라우저 대비

```html
<video>
    <source src={video_webm} type='video/webm' />
    <source src={video} type='video/mp4' />
</video>
```

- WebM 동영상을 지원하지 않는 브라우저에서는 그 다음 소스인 MP4 동영상으로 재생

### 동영상 압축으로 저하된 화질 보완 방법

> 패턴이나 필터로 가려서 사용자로 하여금 동영상의 화질이 좋지 않음을 쉽게 인지할 수 없도록 한다.

**패턴**

**필터**
```css
filter: blur(10px);
```
# 폰트 최적화

# 캐시 최적화

# 불필요한 CSS 제거