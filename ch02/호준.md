# 2장 올림픽 통계 서비스 최적화

## Point

- CSS 애니메이션

- 컴포넌트 지연 로딩 (1장과 다른 점은 단일 컴포넌트를 분할하여 컴포넌트가 쓰이는 순간에 불러오도록 만들 것)

- 이미지 사전 로딩 (이미지가 필요한 시점보다 먼저 다운로드해 두고, 필요할 때 바로 이미지를 보여 줄 수 있도록 하는 이미지 사전 로딩 기법)

#### Jank(쟁크) ??

> - 화면이 버벅거리는 것, 끊김 현상

> - 한 프레임에서 16.7ms(0.0167초)안에 모든 작업이 이루어지지 않으면 사용자는 딜레이 (Jank) 가 생겼다고 느낄수가 있다. 1000ms / 60FPS = 16.7ms

> - 올림픽 통계 서비스의 막대 그래프 애니메이션에서 쟁크 현상이 발생한 이유도 CPU가 다른 일을 하느라 바빠서 초당 60장의 화면을 그리지 못했고 그래서 애니메이션이 끊기는 듯한 느낌을 줬다고 유추해볼 수 있다.

- 애니메이션의 원리는 여러 장의 이미지를 빠르게 전환하여 우리 눈에 잔상을 남기고, 그로 인해 연속된 이미지가 움직이는 것처럼 느껴지게 하는 것.

## 브라우저의 애니메이션 동작 과정

DOM + CSSOM -> 렌더 트리 -> 레이아웃 -> 페인트 -> 컴포지트

이러한 과정을 픽셀 파이프라인 이라고한다.

- DOM, CSSOM : HTML, CSS 등 화면을 그리는데 필요한 리소스를 다운로드하고 파싱해서 DOM을 만든다.

  - 마찬가지로 CSS도 CSSOM이라는 트리 구조를 만들고 각 요소가 어떤 스타일을 포함하고 있는지에 대한 정보를 포함한다.

- 렌더 트리 : DOM, CSSOM의 결합으로 생성되고 화면에 표시되는 각 요소의 레이아웃을 계산하는데 사용

- 레이 아웃 : 렌더 트리가 완성되면 레이아웃 단계로 넘어가는데 화면 구성 요소의 위치나 크기를 계산하고, 해당 위치에 요소를 배치하는 작업을 한다.

- 페인트 : 화면에 배치된 요소에 색을 채워 넣는 작업을 한다. 효율적인 작업을 위해 구성 요소를 여러 개의 레이어로 나눠서 작업한다.

- 컴포지트 : 각 레이어를 합성하는 작업을 한다.

## 리플로우, 리페인트

> 자바스크립트로 인해서 화면 내 어떤 요소의 너비와 높이가 변경되었다면 ?

- 브라우저는 CSSOM을 새로 만들고 새로운 렌더 트리를 만들고 레이아웃 단계에서 다시 요소의 크기와 위치를 고려한다. -> 브라우저 렌더링 경로의 모든 단계를 모두 재실행하기 때문에 브라우저 리소스를 많이 사용한다.

- 리페인트도 마찬가지로 브라우저 리소스를 많이 사용한다. 다만 리플로우와 차이점은 레이아웃 단계를 건너뛴다는 것

## 리플로우와 리페인트를 피하는 방법

- transform
- opacity

> 이런 속성을 사용하면 해당 요소를 별도의 레이어로 분리하고 작업을 GPU에 위임하여 처리해서 레이아웃 단계와 페인트 단계를 건너뛸 수 있다. 이것을 하드웨어 가속이라고 한다.

### will-change??

> 웹 어플리케이션이 진화함으로서 opacity, transform 등의 CSS 속성 값이 동적으로 변화는 상황이 갈수록 자주 생깁니다.
> 동정으로 변화하는 상황시에, will-change 속성을 이용하면 브라우저에 엘리먼트의 어떤 속성이 높은 확률로 변할 것인지 알려 줄 수 있습니다.
> 브라우저는 이것을 통해 앞으로 동적으로 변화할 값을 알고 더 부드러운 이벤트를 구사할 수 있습니다.

> 하드웨어 가속은 은 RAM이나 그래픽 처리 장치(GPU)의 사용량을 커지게하여 페이지에 병목 현상을 줘서 오히려 악영향을 끼치게 한다.
> 위 css핵을 대체할 수 있는 새로운 css 속성이 생겼다. 그 속성이 will-change 이다.
> 브라우저 성능을 최적화 하겠다고 will-change를 과다하게 사용하면 안된다.
> 브라우저는 기본적으로 브라우저가 사용할 수 있는 최적화를 최대한으로 적용한다.
> 그리고 브라우저가 적용한 최적화를 삭제하고 가능한한 빨리 브라우저가 처리해야할 다른 작업들을 실행한다.

> 그런데 will-change를 선언하게 되면 이러한 브라우저의 특성을 무시하고 브라우저가 최적화에 더 많은 시간을 쏟게 한다.
> 즉, 오히려 브라우저 최적화에 악영향을 끼친다.
> 3번과 같은 브라우저 최적화 이슈가 있기 때문에 가능하면 will-change를 사용할 때는 자바스크립트를 사용해서 필요한 순간에만 적용하고 다시 will-change를 초기화 시키는 방법을 적용할 수 있다

> 속성명 그대로 어떤 속성이 변경이 될 것인지 미리 엘리먼트에 적용하여 브라우저가 해당 css를 읽을 때 변경 될 속성을 알게하여 미리 그 변경에 대비할 수 있게 하는 것이다.

    <!-- .thmb 마우스오버시 img 확대 -->
    <div class="item">
    <div class="thmb">
    <img src="picture.jpg">
    </div>
    </div>

    <script>
    // 클릭할 때 애니메이션을 재생할 엘리먼트를 선택합니다.
    var item = document.querySelector('.item');

    // 엘리먼트의 조상 요소에 마우스 커서가 올라가면 will-change를 설정한다.
    item.addEventListener('mouseenter', hintBrowser);
    // 엘리먼트의 조상 요소에 마우스 커서가 내려가면 will-change를 초기화한다.
    item.addEventListener('mouseleave', removeHint);

    function hintBrowser() {
    this.querySelector('img').style.willChange = 'transform, opacity';
    }

    function removeHint() {
    this.querySelector('img').style.willChange = 'auto';
    }
    </script>

https://dev.opera.com/articles/ko/css-will-change-property/

## 이미지 사전 로딩

### 커서가 버튼에 들어오면 미리 사전 로딩

> - onMouseEnter 찰나의 순간을 줄여줌

### 컴포넌트의 마운트 완료 후 사전 로딩

> - new Image()
>   이미지 객체 생성

    useEffect(()=>{
      const component = import('./components/ImageModal');

      const img = new Image();
      img.src='주소'
    },[])

## 고민해볼 점

#### 몇 장의 이미지까지 사전로드 해야하는지??

사전 로딩하는 순간 브라우저의 리소스를 그만큼 많이 사용한다! 고민해보자
